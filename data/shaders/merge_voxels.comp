#version 460 core
#pragma shader_stage(compute)
#extension GL_EXT_samplerless_texture_functions : require

layout(local_size_x=8, local_size_y=8, local_size_z=8) in;

#include "global_set"
layout(set=1, binding=0) uniform texture3D voxel_albedo;
layout(set=1, binding=1, rgba8) uniform image3D voxel_normal;
layout(set=1, binding=2, rgba8) uniform writeonly image3D voxel_radiance;
layout(set=1, binding=3) uniform sampler voxel_sampler;
// layout(set=1, binding=4) uniform textureCube depth_cube;
// layout(set=1, binding=5) uniform sampler depth_cube_sampler;

const float EPSILON = 1e-30;

vec3 to_voxel_space(vec3 p) {
    return (p*0.5+0.5);
} 

float TraceShadow(vec3 position, vec3 direction, float maxTracingDistance) {
    // scaling factor
    float traceShadowHit = 0.8;
    float volumeDimension = 256.0;
    float k = traceShadowHit;
    // navigation
    float voxelTexSize = 2.0 / volumeDimension;
    // move one voxel further to avoid self collision
    float dst = voxelTexSize * 1.0;
    position += direction * dst;
    vec3 cpos = position;
    vec3 samplePos = cpos;
    samplePos = to_voxel_space(samplePos);
    
    // control variables
    float visibility = 0.0;
    // accumulated sample
    float traceSample = 0.0;

    while (visibility <= 1.0 && dst <= maxTracingDistance) 
    {
        if (samplePos.x < 0.0 || samplePos.y < 0.0 || samplePos.z < 0.0
            || samplePos.x > 1.0 || samplePos.y > 1.0 || samplePos.z > 1.0) { 
            break; 
        }
        
        traceSample = ceil(textureLod(sampler3D(voxel_albedo, voxel_sampler), samplePos, 0.0).a) * k;

        if(traceSample > 1.0 - EPSILON) { return 0.0; }

        visibility += (1.0 - visibility) * traceSample * dst;

        dst += voxelTexSize;
        cpos = position + direction * dst;
        samplePos = to_voxel_space(cpos);
    }

    return max(1.0 - visibility, 0.0);
}

vec3 world_to_voxel(vec3 p) {
    return (p*0.5+0.5);
}

void main() {
    if(gl_GlobalInvocationID.x >= 256
        || gl_GlobalInvocationID.y >= 256
        || gl_GlobalInvocationID.z >= 256) {
            return;
    }


    PointLight point_lights[1];
    point_lights[0].pos = vec3(0.0, 0.65, 0.0);
    point_lights[0].col = vec3(1.0);
    point_lights[0].att = vec3(0.2, 0.4, 0.4);
    // point_lights[0].att = vec3(1.0);

    ivec3 write_pos = ivec3(gl_GlobalInvocationID.xyz);
    vec3 normal = normalize(imageLoad(voxel_normal, write_pos).rgb * 2.0 - 1.0);
    vec4 albedo = texelFetch(voxel_albedo, write_pos, 0);

    if(albedo.a < 1e-6) { return; }

    vec4 light = vec4(0.0);
    if(dot(albedo, albedo) > 1e-6) {
        vec3 world_pos = vec3(write_pos) / 255.0; // 0-1
        world_pos = world_pos * 2.0 - 1.0; // real in-game range of voxelized space
        float voxel_size = 2.0 / 256.0; // -1 - +1 in 256 resolution

        PointLight pl = point_lights[0];
        vec3 ldir = pl.pos - world_pos;
        float dist = distance(pl.pos, world_pos);
        ldir /= dist;

        float visibility = TraceShadow(world_pos, ldir, dist);
        float ndotl = max(0.0, dot(normalize(pl.pos - world_pos), normal));
        vec3 res = albedo.rgb * ndotl * pl.col * visibility;
        light = vec4(res, visibility);
    }
    imageStore(voxel_radiance, write_pos, light);
}