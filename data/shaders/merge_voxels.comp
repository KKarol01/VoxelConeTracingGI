#version 460 core
#extension GL_EXT_samplerless_texture_functions : require

layout(local_size_x=8, local_size_y=8, local_size_z=8) in;

#include "global_set"
#include "point_lights"

layout(set=2, binding=0) uniform texture3D voxel_albedo;
layout(set=2, binding=1, rgba8) uniform image3D voxel_normal;
layout(set=2, binding=2, rgba8) uniform writeonly image3D voxel_radiance;
layout(set=2, binding=3) uniform sampler voxel_sampler;

const float EPSILON = 1e-30;

vec3 to_voxel_space(vec3 p) {
    return (p*0.5+0.5);
} 

float calc_occlusion(vec3 ro, vec3 rd, const float max_dist) {
    const float voxel_size = gi_settings.voxel_size;
	float current_dist = voxel_size;
    const float apperture_angle = gi_settings.occlusion_cone_aperture;
	float occlusion = 0.0;
    
	while(current_dist <= max_dist && occlusion < 1.0) {
		float current_coneDiameter = 2.0 * current_dist * tan(apperture_angle * 0.5);
		vec3 pos_worldspace = ro + rd * current_dist;

        float vlevel = log2(current_coneDiameter / voxel_size); // Current mipmap level
        vlevel = min(8.0, max(vlevel, 0.0));

        vec3 pos_texturespace = pos_worldspace * 0.5 + 0.5; // [-1,1] coordinates to [0,1]
		vec4 voxel = textureLod(sampler3D(voxel_albedo, voxel_sampler), pos_texturespace, vlevel);	// Sample
		vec3 color_read = voxel.rgb;
		float occlusion_read = voxel.a;

        occlusion += (1.0 - occlusion) * occlusion_read / (1.0 + current_dist);

		current_dist += max(current_coneDiameter, voxel_size);
	}

    if(gi_settings.merge_voxels_calc_occlusion == 0) { occlusion *= 0.0; }

    return clamp(1.0 - occlusion, 0.0, 1.0);
}

vec3 world_to_voxel(vec3 p) {
    return (p*0.5+0.5);
}

void main() {
    if(gl_GlobalInvocationID.x >= 256
        || gl_GlobalInvocationID.y >= 256
        || gl_GlobalInvocationID.z >= 256) {
            return;
    }

    ivec3 write_pos = ivec3(gl_GlobalInvocationID.xyz);
    vec3 normal = normalize(imageLoad(voxel_normal, write_pos).rgb) * 2.0 - 1.0;
    vec4 albedo = texelFetch(voxel_albedo, write_pos, 0);

    if(albedo.a < 1e-6) { return; }

    vec4 light = vec4(0.0);
    if(dot(albedo, albedo) > 0.0) {
        vec3 world_pos = vec3(write_pos) / 255.0; // 0-1
        world_pos = world_pos * 2.0 - 1.0; // real in-game range of voxelized space
        const float voxel_size = 2.0 / 256.0; // -1 - +1 in 256 resolution

        PointLight pl = point_lights[0];
        vec3 ldir = pl.pos - world_pos;
        float dist = length(ldir);
        ldir /= dist;

        float att = 1.0 / (pl.att[0] + pl.att[1] * dist + pl.att[2] * dist * dist);
        float visibility = calc_occlusion(world_pos, ldir, dist);
        vec3 res = albedo.rgb * pl.col.rgb * pl.col.a * att * visibility;
        light = vec4(res, 1.0);
    }
    imageStore(voxel_radiance, write_pos, light);
}