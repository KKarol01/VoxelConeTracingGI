#version 460 core
#pragma shader_stage(compute)
#extension GL_EXT_samplerless_texture_functions : require

layout(local_size_x=8, local_size_y=8, local_size_z=8) in;

#include "global_set"
layout(set=1, binding=0) uniform texture3D voxel_albedo;
layout(set=1, binding=1, rgba8) uniform image3D voxel_normal;
layout(set=1, binding=2, rgba8) uniform writeonly image3D voxel_radiance;
layout(set=1, binding=3) uniform sampler voxel_sampler;
layout(set=1, binding=4) uniform textureCube depth_cube;
layout(set=1, binding=5) uniform sampler depth_cube_sampler;

const float EPSILON = 1e-30;

float TraceShadow(vec3 position, vec3 direction, float maxTracingDistance) {
    // scaling factor
    float traceShadowHit = 0.5;
    float volumeDimension = 256.0;
    float k = traceShadowHit * traceShadowHit;
    // navigation
    float voxelTexSize = 2.0 / volumeDimension;
    // move one voxel further to avoid self collision
    float dst = voxelTexSize * 1.0;
    vec3 samplePos = direction * dst + position;
    // control variables
    float visibility = 0.0;
    // accumulated sample
    float traceSample = 0.0;

    while (visibility <= 1.0 && dst <= maxTracingDistance) 
    {
        if (samplePos.x < 0.0 || samplePos.y < 0.0 || samplePos.z < 0.0
            || samplePos.x > 1.0 || samplePos.y > 1.0 || samplePos.z > 1.0) { 
            break; 
        }
        
        traceSample = ceil(texture(sampler3D(voxel_albedo, voxel_sampler), samplePos).a) * k;

        if(traceSample > 1.0 - EPSILON) { return 0.0; }

        visibility += (1.0 - visibility) * traceSample / dst;

        dst += voxelTexSize;
        samplePos = direction * dst + position;
    }

    return 1.0 - visibility;
}

void main() {
    if(gl_GlobalInvocationID.x >= 256
        || gl_GlobalInvocationID.y >= 256
        || gl_GlobalInvocationID.z >= 256) {
            return;
    }

    ivec3 write_pos = ivec3(gl_GlobalInvocationID.xyz);
    vec3 normal = imageLoad(voxel_normal, write_pos).rgb * 2.0 - 1.0;
    vec4 albedo = texelFetch(voxel_albedo, write_pos, 0);

    if(albedo.a < 1e-6) { return; }

    vec4 light = vec4(0.0);
    if(dot(albedo, albedo) > 1e-6) {
        vec3 world_pos = vec3(write_pos) / 256.0; // 0-1
        world_pos = world_pos * 2.0 - 1.0; // real in-game range of voxelized space
        float voxel_size = 2.0 / 256.0; // -1 - +1 in 256 resolution

        PointLight pl = point_lights[0];
        vec3 ldir = pl.pos - world_pos;
        float dist = length(ldir);
        ldir /= dist;

        float visibility = TraceShadow(world_pos, ldir, dist);
        float ndotl = max(0.0, dot(ldir, normal));
        vec3 res = albedo.rgb * ndotl * pl.col * visibility * (1.0 / (pl.att[0] + dist*pl.att[1] + dist*dist*pl.att[2]));
        light = vec4(res, visibility);
    }

    imageStore(voxel_radiance, write_pos, light);
}